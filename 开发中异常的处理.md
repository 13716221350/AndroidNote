开发中异常的处理
==============
1.实现未捕捉异常处理器
```java
public class MyExceptionHandler implements UncaughtExceptionHandler {
    private static final String TAG = "MyExceptionHandler";
    @Override
    public void uncaughtException(Thread arg0, Throwable arg1) {
        Logger.i(TAG, "发生了异常,但是被哥捕获了...");
        try {
        Field[] fields = Build.class.getDeclaredFields();//可以通过Build的属性来获取到手机的硬件信息，由于不同手机的硬件信息部一定有，所以要用反射得到
        StringBuffer sb = new StringBuffer();
        for(Field field: fields){
            String info = field.getName()+ ":"+field.get(null)+"\n";
            sb.append(info);
        }
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        arg1.printStackTrace(pw);//通过这个来得到异常信息
        String errorlog = sw.toString();
        
            File file = new File(Environment.getExternalStorageDirectory(),
                    "error.log");
            FileOutputStream fos = new FileOutputStream(file);
            sb.append(errorlog);
            fos.write(sb.toString().getBytes());
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        android.os.Process.killProcess(android.os.Process.myPid());//这个是只能杀死自己不能杀死别人，这时候系统发现程序在自己的范围之内死了，系统就会重启程序到出现错误之前的那个Activity。
    }
}
```
 
前面学了一个`ActivityManage`r的`killBackgroundProcesses`是只能杀死别人不能杀死自
己
2.让这个处理器生效

```java
    /**
     * 代表的是当前应用程序的进程.
     */
    public class MobliesafeApplication extends Application {
        public BlackNumberInfo info;
        
        @Override
        public void onCreate() {
            super.onCreate();
            Thread.currentThread().setUncaughtExceptionHandler(new MyExceptionHandler());//这样就能够让异常的处理器设置到我们的程序中
        }
    }
```

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 