RxJava详解
===

###简介

> Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.

更通俗的意思是为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。
`Annontation`像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。

`Annotation`其实是一种接口。通过反射来访问`annotation`信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。
`Annotation`是不会影响程序代码的执行，无论`annotation`怎么变化，代码都始终如一地执行。
`Java`语言解释器在工作时会忽略这些`annotation`，因此在`JVM`中这些`annotation`是“不起作用”的，只能通过配套的工具才能对这些`annontaion`类型的信息进行访问和处理。

###说明
- `Annotation`的声明是通过关键字`@interface`。这个关键字会去继承`Annotation`接口。
- `Annotation`的方法定义是独特的、受限制的。    
   `Annotation`类型的方法必须声明为无参数、无异常的。这些方法定义了`Annotation`的成员: 方法名代表成员变量名，而方法返回值代表了成员变量的类型。而且方法的返回值类型必须是基本数据类型、`Class`类型、枚举类型、`Annotation`类型或者由前面类型之一作为元素的一维数组。方法的后面可以使用`default`和一个默认的数值来声明成员变量的默认值，`null`不能作为成员变量的默认值，这与我们平时的使用有很大的区别。 
    注解如果只有一个默认属性，可直接用`value()`函数。一个属性也没有则表示该`Annotation`为`Mark Annotation`。    


例如:   
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UseCase {
    public int id();
    public String description() default "no description";
}
```

###作用

`Annotation`一般作为一种辅助途径，应用在软件框架或者工具中。让这些工具类可以根据不同的`Annotation`注解信息来采取不同的处理过程或者改变相应程的行为。   

具体可分为如下三类:    

- 标记，用于告诉编译器一些信息
- 编译时动态处理，如动态生成代码
- 运行时动态处理，如得到注解信息


###Annotation分类    


#####标准的`Annotaion`    

从`jdk 1.5`开始，自带了三种标准的`annotation`类型：   

- `Override`    
    它是一种`marker`类型的`Annotation`，用来标注方法，说明被它标注的方法是重载了父类中的方法。如果我们使用了该注解到一个没有覆盖父类方法的方法时，编译器就会提示一个编译错误的警告。   

- `Deprecated`   
    它也是一种`marker`类型的`Annotation`。当方法或者变量使用该注解时，编译器就会提示该方法已经废弃。

- `SuppressWarnings`  
    它不是`marker`类型的`Annotation`。用户告诉编译器不要再对该类、方法或者成员变量进行警告提示。   


#####元`Annotation`

元`Annotation`是指用来定义`Annotation`的`Annotation`。  

- `@Retention
    保留时间，可为`RetentionPolicy.SOURCE(源码时)`、`RetentionPolicy.CLASS(编译时)`、`RetentionPolicy.RUNTIME(运行时)`，默认为`CLASS`。如果值为`RetentionPolicy.SOURCE`那大多都是`Mark Annotation`，例如:`Override`、`Deprecated`、`Suppress Warnings`。`SOURCE`表示仅存在于源码中，在`class`文件中不会包含。`CLASS`表示会在`class`文件中存在，但是运行时无法获取。`RUNTIME`表示会在`class`文件中存在，并且在运行时可以通过反射获取。    

- `@Target`
    用来标记可进行修饰哪些元素，例如`ElementType.TYPE`、`ElementType.METHOD`、`ElementType.CONSTRUCTOR`、`ElementType.FIELD`、`ElementType.PARAMETER`等，如果未指定则默认为可修饰所有。
- `@Inherited`
    子类是否可以继承父类中的该注解。 
- `@Documented`
    是否会保存到`javadoc`文档中。  

###自定义`Annotation` 

假设现在有个开发团队在每个类的开始都要提供一些信息，例如:   

```java
public class Generation3List extends Generation2List {

   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here

}
```

我们可以声明一个注解来保存这些相同的元数据。如下:    
```java
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
```
声明完注解之后我们就可以填写一些参数来使用它，如下:   

```java
@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // Note array notation
   reviewers = {"Alice", "Bob", "Cindy"}
)
public class Generation3List extends Generation2List {

// class code goes here

}
```







###`Annotation`解析    


当Java源代码被编译时，编译器的一个插件annotation处理器则会处理这些annotation。处理器可以产生报告信息，或者创建附加的Java源文件或资源。如果annotation本身被加上了RententionPolicy的运行时类，则Java编译器则会将annotation的元数据存储到class文件中。然后，Java虚拟机或其他的程序可以查找这些元数据并做相应的处理。

当然除了annotation处理器可以处理annotation外，我们也可以使用反射自己来处理annotation。Java SE 5有一个名为AnnotatedElement的接口，Java的反射对象类Class,Constructor,Field,Method以及Package都实现了这个接口。这个接口用来表示当前运行在Java虚拟机中的被加上了annotation的程序元素。通过这个接口可以使用反射读取annotation。AnnotatedElement接口可以访问被加上RUNTIME标记的annotation，相应的方法有getAnnotation,getAnnotations,isAnnotationPresent。由于Annotation类型被编译和存储在二进制文件中就像class一样，所以可以像查询普通的Java对象一样查询这些方法返回的Annotation。


#####运行时`Annotation`解析
该类是指`@Retention`为`RUNTIME`的`Annotation`。
该类型的解析其实本质的使用反射。反射执行的效率是很低的
如果不是必要，应当尽量减少反射的使用，因为它会大大拖累你应用的执行效率。

例如`Target`为`Method`的注解就可以通过`Method`中的如下方法进行解析:      

```java

public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
    ...
}

public Annotation[] getAnnotations() {
    ...
}

public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
    ...
}
```

当然如果`Target`为`Field`、`Class`等那就要去使用`Filed`或`Class`中的方法来解析了。      
```java
public static void main(String[] args) {
    try {
        Class cls = Class.forName("cn.trinea.java.test.annotation.App");
        for (Method method : cls.getMethods()) {
            MethodInfo methodInfo = method.getAnnotation(
MethodInfo.class);
            if (methodInfo != null) {
                System.out.println("method name:" + method.getName());
                System.out.println("method author:" + methodInfo.author());
                System.out.println("method version:" + methodInfo.version());
                System.out.println("method date:" + methodInfo.date());
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}
```




#####编译时`Annotation`解析    

该类值`@Retention`为`CLASS`的`Annotation`，由`APT(Annotaion Processing Tool)`自动进行解析。是在编译时注入，所以不会像反射一样影响效率问题。   

我们需要做的是:    

- 自定义类继承`AbstractProcessor`
- 重写`process`方法

例如:    

```java
@SupportedAnnotationTypes({ "cn.trinea.java.test.annotation.MethodInfo" })
public class MethodInfoProcessor extends AbstractProcessor {
 
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
        HashMap<String, String> map = new HashMap<String, String>();
        for (TypeElement te : annotations) {
            for (Element element : env.getElementsAnnotatedWith(te)) {
                MethodInfo methodInfo = element.getAnnotation(MethodInfo.class);
                map.put(element.getEnclosingElement().toString(), methodInfo.author());
            }
        }
        return false;
    }
}
```
SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。
process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境
process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理



###使用注解提高代码的检查性    

`Google`提供了`Support-Annotations library`来支持更多的注解功能。   
可以直接在`build.gradle`中添加如下代码:    

```
dependencies {
    compile 'com.android.support:support-annotations:23.3.0'
}
```

`Android`提供了很多注解来支持在方法、参数和返回值上面使用，例如:    

- `@Nullable`
    可以为`null`

- `@NonNull`
    不能为`null`
- `@StringRes`
    `R.string`类型的资源。 
- `@DrawableRes`
    `Drawable`类型的资源。
- `@ColorRes`    
    `Color`类型的资源。
- `@InterpolatorRes`
    `Interpolatro`类型。
- `@AnyRes`
    `R.`类型。
- `@UiThread`
    从`UI thread`调用。 
- `@RequiresPermission`
    来验证该方法的调用者所需要有的权限。检查一个列表中的任何一个权限可以使用`anyOf`属性。想要检查多个权限时，可以使用`allOf`属性。如下:  
```java
@RequiresPermission(Manifest.permission.SET_WALLPAPER)
public abstract void setWallpaper(Bitmap bitmap) throws IOException;
```
检查多个权限:   

```java
@RequiresPermission(allOf = {
    Manifest.permission.READ_EXTERNAL_STORAGE,
    Manifest.permission.WRITE_EXTERNAL_STORAGE})
public static final void copyFile(String dest, String source) {
    ...
}

```



例如:   

```java
import android.support.annotation.NonNull;
...

    /** Add support for inflating the <fragment> tag. */
    @NonNull
    @Override
    public View onCreateView(String name, @NonNull Context context,
      @NonNull AttributeSet attrs) {
      ...
      }
...
```

```java
import android.support.annotation.StringRes;
...
    public abstract void setTitle(@StringRes int resId);
    ...

遇到那种你写了个`setTitle(int resId)`他确给你传`setTitle(R.drawable.xxx)`的选手，用这种方式能很好的去提示下。 
```

		
---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
