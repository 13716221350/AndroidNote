知识大杂烩
=========
1.开启服务是*Intent*传递数据
---
- 当开启一个`Service`时，如果要通过`Intent`去传递一些数据，在`Service`的`onStartCommand`方法中有一个参数`Intent`，我们可以通过这个`Intent`来得到传递过来的数据    

```java
public class TestService extends Service {

    @Override
    public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		Log.i("@@@", intent.getStringExtra("aa"));
		return super.onStartCommand(intent, flags, startId);
	}
}
```

2.*JVM*与*Dalvik*虚拟机的区别
---
- *JVM*是基于栈的架构(内存)，编译过程为`.java`->`.class`->`.jar`    
- *Dlvik(DVM)*是基于寄存器的架构(*CPU*里面的存储空间,*CPU*操作数据比内存要快)，编译过程为`.java`->`.class`->`.dex`->`.odex`
- 一个应用，一个虚拟机实例，一个进程
 1. 每一个`Android`应用都运行在一个`Dalvik`虚拟机实例里，而每一个虚拟机实例都是一个独立的进程空间。每个进程之间可以通信（`IPC`，`Binder`机制实现）。虚拟机的线程机制，内存分配和管理，`Mutex`等等都是依赖底层操作系统而实现的。
 2. 不同的应用在不同的进程空间里运行，当一个虚拟机关闭或意外中止时不会对其它 虚拟机造成影响，可以最大程度的保护应用的安全和独立运行。

3.Eclipse下关联support v4源码
-------
- 在`libs`目录下新建`android-support-v4.jar.properties`文件  
内容为`src = D:\\Java\\adt-bundle-windows\\sdk\\extras\\android\\support\\v4\\src`,`(即指向adt中的support v4源码文件)`   
然后刷新即可关联support v4源码。

4.自定义对话框
------
    
示例代码：
```java
public void showDialog() {
    AlertDialog.Builder builder = new Builder(this);
    View view = View.inflate(this, R.layout.dialog, null);
    builder.setView(view);//将自定义的View设置到对话框中
    builder.show()
}
```
但是会发现对话框上面和下面都有一个小黑背景，这是因为对话框的默认背景是黑色的。那么怎么才让它去掉上面的黑背景呢？

```java
public void showDialog() { 
    AlertDialog.Builder builder = new Builder(this);
    View view = View.inflate(this, R.layout.dialog, null);
    AlertDialog dialog = builder.create();
    dialog.setView(view,0,0,0,0);//设置填空的view据对话框的上下左右的距离
    dialog.show();
}
```
5.EditText添加内容改变的监听器
-----
```java
mEditText.addTextChangedListener(new TextWatcher() {
    //EditText中文本内容改变的时候自动调用的方法
    public void onTextChanged(CharSequence s, int start, int before, int count) {
        //这个CharSequence就是当前的文本输入框中的内容
        String address  = AddressDao.getAddress(s.toString());
        tv_numberquery_address.setText(address);
    }
    
    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        
    }
    
    public void afterTextChanged(Editable s) {
        
    }
});
```

6.Android版本适配
---
对于Android的不同版本其功能可能不一样，我们要通过`Build.VERSION.SDK_INT`来判断当前系统的版本，从而根据不同的版本来设置不同的操作

这里以进入到`Setting`清楚缓存的界面为例
```java
public void onClick(View v) {
	if (Build.VERSION.SDK_INT >= 9) {
		// 适合2.3 以及以上系统
		Intent intent = new Intent();
		intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS");
		intent.addCategory("android.intent.category.DEFAULT");
		intent.setData(Uri.parse("package:" + packname));
		startActivity(intent);
	} else {
		// 适合2.2 以及以下系统
		Intent intent = new Intent();
		intent.setAction("android.intent.action.VIEW");
		intent.addCategory("android.intent.category.DEFAULT");
		intent.addCategory("android.intent.category.VOICE_LAUNCH");
		intent.putExtra("pkg", packname);
		startActivity(intent);
	}
}
```

7.手机重启
-----
  通过不断的`new`出来空白的`Toast`把系统弄崩溃，这样系统就会重启    
```java
public void click(View view) {
    while (true) {
        Toast toast = new Toast(this);
        toast.setView(new View(this));
        toast.show();
    }
}
```

8.adb shell 启动应用
---------------------------
启动的方法为
```
$ adb shell
$ am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}
```
由此计算器（calculator）的启动方法为：    
```
am start -n com.android.calculator2/.Calculator
```

启动浏览器 :
```
am start -a android.intent.action.VIEW -d  http://www.google.cn/
```

拨打电话 :
```
am start -a android.intent.action.CALL -d tel:10086
```
9.启动APK默认Activity
------------------
```java
public static void startApkActivity(final Context ctx, String packageName) {
        PackageManager pm = ctx.getPackageManager();
        PackageInfo pi;
        try {
            pi = pm.getPackageInfo(packageName, 0);
            Intent intent = new Intent(Intent.ACTION_MAIN, null);
            intent.addCategory(Intent.CATEGORY_LAUNCHER);
            intent.setPackage(pi.packageName);

            List<ResolveInfo> apps = pm.queryIntentActivities(intent, 0);

            ResolveInfo ri = apps.iterator().next();
            if (ri != null) {
                String className = ri.activityInfo.name;
                intent.setComponent(new ComponentName(packageName, className));
                ctx.startActivity(intent);
            }
        } catch (NameNotFoundException e) {
            Log.e("startActivity", e);
        }
    }
}
```

10.TextView行间距
-----------
`Android`系统中`TextView`默认显示中文时会比较紧凑，不是很美观。   
为了让每行保持一定的行间距，可以设置属性`android:lineSpacingExtra`或`android:lineSpacingMultiplier`

1.android:lineSpacingExtra    
设置行间距，如”3dp”。

2.android:lineSpacingMultiplier     
设置行间距的倍数，如”1.2″。

11.Android Pull Push命令
-----------------------
adb命令下pull的作用是从手机端向电脑端拷文件。
命令：
```
//将手机卡中的某个文本文件复制到电脑D盘
adb pull /sdcard/**.txt   D:\                         
adb pull /data/data/com.ifeng.newvideo/databases/ifengVideoV6.db e:/
```

push的作用和pull正好相反， 是从电脑端向手机复制文件的。下面是例子
```
adb push d:\lzd.doc /mnt/sdcard/jaj_training/fingerprint/
```

**注意：这些命令都是在adb下用，而不是在shell中用。**

12.Android 4.0横竖屏切换
--------------------
==Android 2.3以前的横竖屏切换==

在Android 2.3平台上，我们可以需要设置界面的横竖屏显示时，可以在AndroidManifest.xml中，对Activity的属性添加以下代码：

    android:configChanges="keyboardHidden|orientation"同时在Activity中覆写onConfigurationChanged方法

==Android 4.0以后的横竖屏切换==

当我们在4.0上像之前那样设置横竖屏时，会发现竟然没有效果，Activity依然走自己的生命周期，这是因为在API level 13以后Android做了修改了，当设备横竖屏切换时屏幕尺寸也改变了。因此，如果你想在API Level 13或者更高的环境下，像以前那样阻止设备的横竖屏切换，你需要在orientation后加上screenSize。也就说你要像这样声明：
```
android:configChanges="keyboardHidden|orientation|screenSize"
```   
同时依然要在Activity中覆写onConfigurationChanged方法
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        Log.i("TAG","I'm Android 4.0");
    }

----
- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
